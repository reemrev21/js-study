<!DOCTYPE html>
<html>
<head>
  <title>Document</title>
</head>
<body>
  <script> 
    // 3차원 행렬 -> 큐브 형태
    // 파이와 썬은 8로 표시
    // 각 큐브에 세계진 값은 가중치 입니다. 
    // 이 가중치를 더해 파이에서 썬으로가는 최단거리를 구하고, 
    // 최단경로를 행렬의 좌표값으로 출력하시오. 
    // (해당 형태가 Cube 형태임을 감안하여 최단거리를 구해야 합니다.)
    // 사분면 제한
      // 1. 2사분면 → 4사분면
      // 2. 2사분면 → 1사분면 → 4사분면
      // 3. 2사분면 → 0사분면 → 5사분면 → 4사분면
    // 방향 제한 (택1)
      // 1. 오른쪽으로 이동하거나 아래로 이동
      // 2. 오른쪽으로 이동하거나 위로 이동
      // 3. 왼쪽으로 이동하거나 아래로 이동
      // 4. 왼쪽으로 이동하거나 위로 이동

    // 문제 풀이 방법
     // 1. graph로 바꿔서 다익스트라 알고리즘을 사용
        // --> 신입사원 수준 X
     // 2. matrix 형태의 동적 계획법
      // - Recursion
      // - memorization
      // - for문 ---> we choose! 
    // 2, 4 분면만 이용 
    // 3차원이므로 2개의 for문이 필요 -- > flat()이용

    cross = [[[3, 0, 1, 1, 8],
              [5, 0, 4, 5, 4],
              [1, 5, 0, 5, 1],
              [1, 2, 1, 0, 1],
              [0, 2, 5, 1, 1]],

             [[1, 2, 0, 3, 3],
              [1, 2, 0, 2, 4],
              [1, 2, 0, 2, 4],
              [4, 2, 0, 0, 1],
              [8, 4, 1, 1, 0]]]
    
    // flat(depth)
    // flat(2) --> 1차원 array
    cross = cross.flat()

    
  let c =  [[3, 0, 1, 1, 8],
            [5, 0, 4, 5, 4],
            [1, 5, 0, 5, 1],
            [1, 2, 1, 0, 1],
            [0, 2, 5, 1, 1]]

  // Array(5).fill(0) ---> 1차원 array
  // Array(5).fill(0).map(() => Array(5).fill(0)) ---> 5*5
  let 가중치누적값 = Array(5).fill(0).map(() => Array(5).fill(0))
  console.log(가중치누적값)

  for (var i = 0; i < c.length; i++) {
    // 컬럼은 고정값 사용
    for (var j = 0; j < 5; j++) {
      if (i == 0 && j == 0) {
        가중치누적값[0][0] = c[0][0]
      }
      else if (i == 0) {
        // 가중치누적값[i][j-1] 
        // 컬럼의 전 값만 나 자신에게 더해주면 된다.
        // 나까지 오는 경로는 유일하기 때문
        가중치누적값[i][j] = 가중치누적값[i][j-1] + c[i][j]
      }
      else if (j == 0) {
        가중치누적값[i][j] = 가중치누적값[i-1][j] + c[i][j]
      }
      else {
        가중치누적값[i][j] = Math.min(가중치누적값[i][j-1], 가중치누적값[i-1][j]) + c[i][j]
      }
    }

    console.log(c)
    console.log(가중치누적값)

    // [[0,0], [0,0], [0,0], [0,0], [0,0] ... *5]
    let 좌표저장 = Array(5).fill(0).map(() => Array(5).fill(0).map(() => Array(2).fill(0)))
    console.log(좌표저장)
    for (var i = 0; i < c.length; i++) {
    // 컬럼은 고정값 사용
      for (var j = 0; j < 5; j++) {
        if (i == 0 && j == 0) {
          가중치누적값[0][0] = c[0][0]
          좌표저장[0][0][0] = i
          좌표저장[0][0][1] = j
        }
        else if (i == 0) {
          // 가중치누적값[i][j-1] 
          // 컬럼의 전 값만 나 자신에게 더해주면 된다.
          // 나까지 오는 경로는 유일하기 때문
          가중치누적값[i][j] = 가중치누적값[i][j-1] + c[i][j]
          // 내가 참조했던 값의 좌표를 저장
          좌표저장[i][j][0] = i
          좌표저장[i][j][1] = j-1
        }
        else if (j == 0) {
          가중치누적값[i][j] = 가중치누적값[i-1][j] + c[i][j]
          좌표저장[i][j][0] = i-1
          좌표저장[i][j][1] = j
        }
        else {
          // 가중치누적값[i][j] = Math.min(가중치누적값[i][j-1], 가중치누적값[i-1][j]) + c[i][j]
          if(가중치누적값[i][j-1] > 가중치누적값[i-1][j]) {
            // 가중치누적값[i-1][j] 이 값을 참조한 것 
            가중치누적값[i][j] = 가중치누적값[i-1][j] + c[i][j]
            좌표저장[i][j][0] = i-1
            좌표저장[i][j][1] = j
          } else{
            가중치누적값[i][j] = 가중치누적값[i][j-1] + c[i][j]
            좌표저장[i][j][0] = i
            좌표저장[i][j][1] = j-1
          }
        }
      }
    } 

  console.log(좌표저장)
  console.log(cross)

  가중치누적값 = Array(cross.length).fill(0).map(() => Array(5).fill(0))
  //  Array(2) = (x, y)
  좌표저장 = Array(cross.length).fill(0).map(() => Array(5).fill(0).map(() => Array(2).fill(0)))

  console.log(가중치누적값)
  console.log(좌표저장)
  
  for (var i = 0; i < cross.length; i++) {
    // 8이 대각선에 있으므로
      for (var j = 4; j > -1; j--) {
        if (i == 0 && j == 4) {
          가중치누적값[0][4] = cross[0][4]
          // 마지막 같이 중복 되니까 임의로 99로 변경
          좌표저장[0][4][0] = 99
          좌표저장[0][4][1] = 99
        }
        else if (i == 0) {
          // 가중치누적값[i][j-1] 
          // 컬럼의 전 값만 나 자신에게 더해주면 된다.
          // 나까지 오는 경로는 유일하기 때문
          가중치누적값[i][j] = 가중치누적값[i][j+1] + cross[i][j]
          // 내가 참조했던 값의 좌표를 저장
          좌표저장[i][j][0] = i
          좌표저장[i][j][1] = j+1
        }
        else if (j == 4) {
          가중치누적값[i][j] = 가중치누적값[i-1][j] + cross[i][j]
          좌표저장[i][j][0] = i-1
          좌표저장[i][j][1] = j
        }
        else {
          // 가중치누적값[i][j] = Math.min(가중치누적값[i][j-1], 가중치누적값[i-1][j]) + c[i][j]
          if(가중치누적값[i][j+1] > 가중치누적값[i-1][j]) {
            // 가중치누적값[i-1][j] 이 값을 참조한 것 
            가중치누적값[i][j] = 가중치누적값[i-1][j] + cross[i][j]
            좌표저장[i][j][0] = i-1
            좌표저장[i][j][1] = j
          } else{
            가중치누적값[i][j] = 가중치누적값[i][j+1] + cross[i][j]
            좌표저장[i][j][0] = i
            좌표저장[i][j][1] = j+1
          }
        }
      }
    } 
    let i_ = 0;
    let j_ = 0
      console.log(가중치누적값)
      console.log(좌표저장)

      // 맨 밑에 좌표 
      for (var k = 0; k < 100; k++) {        
        if (i_ == 99 || j_ == 99) {
          break
        }

        if(k == 0) {
          i_ = 좌표저장[cross.length-1][0][0]
          j_ = 좌표저장[cross.length-1][0][1]
        } 
        else {
          i_ = 좌표저장[i_][j_][0]
          j_ = 좌표저장[i_][j_][1]
        }
          console.log(i_, j_)
      }

      
  }
 
  </script>
</body>
</html>